"""
socket control

note: don't import files except tools to escape dependency problem
"""
from p2p_python.tools import *
from threading import Thread, Lock, Event
from queue import Queue, Empty
from srudp import SecureReliableSocket
from select import select
from socket import socket
import socket as s
from enum import Enum, IntFlag
from typing import TYPE_CHECKING, List, Union, Optional, Callable, Type
from ecdsa.keys import SigningKey, VerifyingKey
from Cryptodome.Random import get_random_bytes
from binascii import a2b_hex
from hashlib import sha256
from time import time, sleep
from ipaddress import IPv4Address, IPv6Address
import logging
import random
import json
import zlib


get_uuid = uniq_id_generator()
CallbackReceive = Callable[[bytes, 'Sock'], None]
CallbackAccept = Callable[['Sock', 'SockPool'], None]
CallbackClose = Callable[['Sock', 'SockPool'], None]
log = logging.getLogger(__name__)


class SockControl(IntFlag):
    """sock control bits"""
    NOTHING = 0b00000000
    ENCRYPTED = 0b00000001
    COMPRESSED = 0b00000010
    VALIDATED = 0b00000100
    INNER_WORK = 0b00001000
    WARNING = 0b00010000
    # reserved 0b00100000
    # reserved 0b01000000
    CLOSING = 0b10000000


class SockType(Enum):
    """sock types"""
    SERVER = 0  # server: wait for new connection (TCP)
    INBOUND = 1  # client: incoming connection generated by server (TCP)
    OUTBOUND = 2  # client: outgoing connection made by us (TCP or SRUDP)


class InnerWorkBase(Thread):
    def __init__(self, is_primary: bool, sock: 'Sock'):
        super().__init__()
        self.uuid = random.randint(10000, 99999) if is_primary else -1
        self.is_primary = is_primary
        self.sock = sock
        self.que: Queue[_Dict] = Queue()
        self.event = Event()
        self.error: Optional[str] = None

    def __repr__(self) -> str:
        if self.error is not None:
            status = "FAILED(" + self.error + ")"
        elif self.event.is_set():
            status = "COMPLETE"
        elif not self.que.empty():
            status = "waiting"
        else:
            status = "processing"
        return f"<{self.display()} {status} uuid={self.uuid}>"

    def display(self) -> str:
        """className(is_primary)"""
        return f"{type(self).__name__}({self.is_primary})"

    def run(self) -> None:
        """run by start()"""
        assert self.uuid != -1
        assert not self.event.is_set()
        now = time()

        # start
        log.debug(f"start %s", self.display())
        status = "incomplete"
        try:
            self.inner_work()
            status = "success"
        except Empty:
            log.debug("EmptyError, queue is empty on %s", self.display())
            self.error = "EmptyError"
        except AssertionError as e:
            log.debug("AssertionError %s on %s", e, self.display())
            self.error = "AssertionError: " + str(e)
        except Exception as e:
            log.warning("Exception", exc_info=True)
            self.error = "Exception: " + str(e)
        finally:
            # finish
            log.debug("%s %s by %fs", status, self.display(), time() - now)
            self.event.set()

    def inner_work(self) -> None:
        """overwrite here"""
        raise NotImplementedError("inner_work() of" + self.display())

    def send_json(self, obj: _Dict) -> None:
        """send inner work msg by plain"""
        self.sock.sendall(json.dumps(obj).encode() + b"\n", SockControl.INNER_WORK)

    def recv_json(self) -> _Dict:
        """recv inner work msg or raise queue.Empty"""
        return self.que.get(True, 20.0)


class InnerWorkEncryption(InnerWorkBase):
    """for protection of data stream"""
    def __init__(self, is_primary: bool, sock: 'Sock'):
        super().__init__(is_primary, sock)

    def inner_work(self) -> None:
        common_key: Optional[bytes] = None
        shared_key: Optional[bytes] = None
        established_msg = b"success establish encrypted connection"
        my_pk: VerifyingKey

        # first stage
        if self.is_primary:
            # (primary): generate pair, send pk & curve
            my_sk = SigningKey.generate(CURVE)
            my_pk = my_sk.get_verifying_key()
            self.send_json({
                "uuid": self.uuid,
                "ignite": "encryption",
                "curve": str(CURVE.name),
                "public-key": my_pk.to_string().hex()
            })
        else:
            # (standby): receive pk, calc sharedKey, send
            my_sk = SigningKey.generate(CURVE)
            my_pk = my_sk.get_verifying_key()
            obj = self.recv_json()
            assert str(obj.get("curve")) == CURVE.name, "{} is not same curve".find(obj.get("curve"))
            assert "public-key" in obj
            other_pk = VerifyingKey.from_string(a2b_hex(obj["public-key"]), curve=CURVE)
            shared_key = get_shared_key(my_sk, other_pk)
            common_key = get_random_bytes(32)
            encrypted_key = encrypt(shared_key, common_key)
            self.send_json({
                "uuid": self.uuid,
                "public-key": my_pk.to_string().hex(),
                "encrypted-key": encrypted_key.hex()
            })

        # second stage
        if self.is_primary:
            # (primary): receive pk & encryptedKey, calc sharedKey
            # decrypt commonKey, send hell msg
            obj = self.recv_json()
            assert "public-key" in obj
            other_pk = VerifyingKey.from_string(a2b_hex(obj["public-key"]), curve=CURVE)
            shared_key = get_shared_key(my_sk, other_pk)
            assert "encrypted-key" in obj
            common_key = decrypt(shared_key, a2b_hex(obj["encrypted-key"]))
            encrypted_msg = encrypt(shared_key, established_msg)
            self.send_json({
                "uuid": self.uuid,
                "encrypted-msg": encrypted_msg.hex()
            })
        else:
            # (standby): receive encrypted msg, confirm connection by decrypting
            obj = self.recv_json()
            assert "encrypted-msg" in obj
            assert isinstance(shared_key, bytes)
            msg = decrypt(shared_key, a2b_hex(obj["encrypted-msg"]))
            assert msg == established_msg

        # success
        with self.sock.lock:
            self.sock.common_key = common_key
            self.sock.flags |= SockControl.ENCRYPTED


class InnerWorkValidation(InnerWorkBase):
    """identify of the other socket"""
    def __init__(self, is_primary: bool, sock: 'Sock'):
        super().__init__(is_primary, sock)

    def inner_work(self) -> None:
        random_key = get_random_bytes(32)
        another_key: Optional[bytes] = None
        others_key: Optional[VerifyingKey] = self.sock.others_key
        signature: bytes

        # first stage
        if self.is_primary:
            self.send_json({
                "uuid": self.uuid,
                "ignite": "validation",
                "curve": str(CURVE.name),
                "another-key": random_key.hex(),
            })
        else:
            obj = self.recv_json()
            assert str(obj.get("curve")) == CURVE.name, "{} is not same curve".find(obj.get("curve"))
            assert "another-key" in obj
            another_key = a2b_hex(obj["another-key"])
            assert len(another_key) == 32
            # sign
            signature = self.sock.secret_key.sign(random_key + another_key, hashfunc=sha256)
            my_public_key = self.sock.secret_key.get_verifying_key()
            self.send_json({
                "uuid": self.uuid,
                "another-key": random_key.hex(),
                "public-key": my_public_key.to_string().hex(),
                "signature": signature.hex()
            })

        # second stage
        if self.is_primary:
            obj = self.recv_json()
            assert "another-key" in obj
            another_key = a2b_hex(obj["another-key"])
            assert len(another_key) == 32
            assert "public-key" in obj
            others_public_key = a2b_hex(obj["public-key"])
            assert "signature" in obj
            others_signature = a2b_hex(obj["signature"])
            # verify
            if others_key is None:
                others_key = VerifyingKey.from_string(others_public_key, curve=CURVE)
            else:
                assert others_public_key == others_key.to_string(), "don't match public key"
            others_key.verify(others_signature, another_key + random_key, hashfunc=sha256)
            # sign
            signature = self.sock.secret_key.sign(random_key + another_key, hashfunc=sha256)
            my_public_key = self.sock.secret_key.get_verifying_key()
            self.send_json({
                "uuid": self.uuid,
                "public-key": my_public_key.to_string().hex(),
                "signature": signature.hex(),
            })
        else:
            obj = self.recv_json()
            assert "public-key" in obj
            others_public_key = a2b_hex(obj["public-key"])
            assert "signature" in obj
            others_signature = a2b_hex(obj["signature"])
            # verify
            if others_key is None:
                others_key = VerifyingKey.from_string(others_public_key, curve=CURVE)
            else:
                assert others_public_key == others_key.to_string(), "don't match public key"
            others_key.verify(others_signature, another_key + random_key, hashfunc=sha256)

        # success
        with self.sock.lock:
            self.sock.others_key = others_key
            self.sock.flags |= SockControl.VALIDATED


class InnerWorkMeasureTime(InnerWorkBase):
    """measure socket delay and confirm stram is stable"""
    def __init__(self, is_primary: bool, sock: 'Sock'):
        super().__init__(is_primary, sock)

    def inner_work(self) -> None:
        others_now: Optional[float] = None

        # first stage
        if self.is_primary:
            my_now = time()
            self.send_json({
                "uuid": self.uuid,
                "ignite": "measure-delay",
                "now": my_now,
            })
        else:
            obj = self.recv_json()
            assert "now" in obj
            others_now = obj["now"]
            my_now = time()
            self.send_json({
                "uuid": self.uuid,
                "now": my_now,
            })

        # second stage
        if self.is_primary:
            obj = self.recv_json()
            assert "now" in obj
            others_now = obj["now"]
        else:
            pass

        # success
        with self.sock.lock:
            self.sock.delay = others_now - my_now
        if self.sock.stable.is_set() is False:
            log.debug(f"{self} is stabled now")
            self.sock.stable.set()


class UnrecoverableClose(Exception):
    """data processing has collapsed and socket is closed"""


class GracefulCloseSignal(Exception):
    """signaled by the other 'we are closing now'"""


class JobCorruptedWarning(Warning):
    """a job was damaged in a process and socket is returned to other job"""


class Sock(object):
    """client socket object wrapper and callback"""

    def __init__(
            self,
            sock: socket,
            callback: CallbackReceive,
            stype: SockType,
            others_key: Optional[VerifyingKey],
            secret_key: SigningKey,
    ):
        assert sock.gettimeout() == 0.0, "only non-blocking mode"
        assert sock.family in (s.AF_INET, s.AF_INET6)
        assert sock.type & s.SOCK_STREAM, (sock, s.SOCK_STREAM)
        self.id = get_uuid()
        self.sock = sock
        self.lock = Lock()
        self.callback = callback
        self.inner_work_list: List[InnerWorkBase] = list()
        self.stype = stype
        self.tmp = bytearray()  # recv buffer
        self.common_key: Optional[bytes] = None  # 32bytes AES key
        self.others_key = others_key  # others public key
        self.secret_key = secret_key  # my secret key
        self.flags = SockControl.NOTHING  # default no flag
        # check stable by `stable.is_set()`
        self.stable = Event()
        self.delay = 0.0
        self.time = time()

    def __repr__(self) -> str:
        class_name = str(self.sock.__class__.__name__)
        if self.sock.fileno() == -1:
            host = "closed"
        elif not self.stable.is_set():
            host = "unstable"
        else:
            host = str(self.get_opposite_host())
        flag = "flag=" + \
            ("E" if self.flags & SockControl.ENCRYPTED else "_") + \
            ("C" if self.flags & SockControl.COMPRESSED else "_") + \
            ("V" if self.flags & SockControl.VALIDATED else "_")
        family = getattr(self.sock.family, "name", str(self.sock.family))
        uptime = time2string(time() - self.time)
        return f"<Sock:{class_name} {host} id={self.id} {flag} {self.stype.name} {family} {uptime}>"

    def recv(self) -> None:
        """push new raw bytes and find new chunk msg"""
        assert self.stype in (SockType.INBOUND, SockType.OUTBOUND)

        data = self.sock.recv(4096)
        if len(data) == 0:
            raise UnrecoverableClose("receive zero message (socket is closed)")
        self.tmp.extend(data)

        while self.tmp:
            flag = self.tmp[0]  # 1byte
            length = int.from_bytes(self.tmp[1:5], "little")  # 4bytes

            if len(self.tmp) < 5 + length:
                return  # not found new msg

            # find new chunked msg
            msg = bytes(self.tmp[5:5 + length])
            self.tmp = self.tmp[5 + length:]

            # decrypt
            if flag & SockControl.ENCRYPTED:
                if self.common_key is None:
                    if self.stable.is_set():
                        # note: stabled but not found key is unexpected
                        raise UnrecoverableClose("try to decrypt msg but not found key (stable)")
                    else:
                        # note: notify decryption failed on unstable condition
                        raise JobCorruptedWarning("try to decrypt msg but not found key (unstable)")
                msg = decrypt(self.common_key, msg)

            # decompress
            if flag & SockControl.COMPRESSED:
                msg = zlib.decompress(msg)

            """execute callback with same thread"""
            if PRINT_SOCK_MSG:
                log.info(f"{self} recv {msg!r}")

            # warning: don't block because a listen thread fall in dysfunctional
            if flag & SockControl.INNER_WORK:
                obj: _Dict = json.loads(msg.decode(errors="ignore"))
                for work in self.inner_work_list:
                    if work.uuid == obj["uuid"]:
                        work.que.put(obj)
                        break
                else:
                    # not found uuid
                    # start new work thread
                    self._ignite_inner_work(obj)

            elif flag & SockControl.WARNING:
                # just warning log by the other
                log.warning(f"warning {self}: {msg.decode(errors='ignore')}")

            elif flag & SockControl.CLOSING:
                # closing request
                raise GracefulCloseSignal(f"closing request: {msg.decode(errors='ignore')}")

            else:
                # is outer work
                self.callback(msg, self)

    def sendall(self, msg: bytes, flag: int = None) -> None:
        """send chunked message"""
        assert self.stype in (SockType.INBOUND, SockType.OUTBOUND)
        # assert self.stable.is_set(), "wait for sock is stabled"

        # manual setup flag
        if flag is None:
            flag = self.flags

        # don't send normal msg on unstable
        if (not flag & SockControl.INNER_WORK) and (not self.stable.is_set()):
            log.warning(f"you send normal msg on unstable flag={flag} msg={msg!r}")

        if PRINT_SOCK_MSG:
            log.info(f"{self} send {msg!r}")

        # compress
        if flag & SockControl.COMPRESSED:
            msg = zlib.compress(msg)

        # encrypt
        if flag & SockControl.ENCRYPTED:
            if self.common_key is None:
                raise JobCorruptedWarning("try to encrypt msg but not found key")
            else:
                msg = encrypt(self.common_key, msg)

        # send
        with self.lock:
            # convert: [flag 1b][len 4b][msg xb]
            self.sock.sendall(flag.to_bytes(1, "little") + len(msg).to_bytes(4, "little") + msg)

    def _ignite_inner_work(self, obj: _Dict) -> None:
        """start inner work thread by ignite"""
        work: InnerWorkBase

        if "ignite" not in obj:
            raise JobCorruptedWarning("no ignite flag and no inner work")
        elif obj["ignite"] == "encryption":
            work = InnerWorkEncryption(False, self)
        elif obj["ignite"] == "validation":
            work = InnerWorkValidation(False, self)
        elif obj["ignite"] == "measure-delay":
            work = InnerWorkMeasureTime(False, self)
        else:
            raise NotImplementedError(f"unknown ignite flag: {obj}")

        self.inner_work_list.append(work)
        work.uuid = obj["uuid"]
        work.que.put(obj)
        work.start()

    def establish_encryption(self, is_primary: bool) -> Event:
        """establish encrypted connection"""
        assert self.common_key is None, "already established encryption (key)"
        assert not (self.flags & SockControl.ENCRYPTED), "already established encryption (flag)"
        if is_primary and self.stype != SockType.INBOUND:
            log.warning("establish_encryption() is INBOUND work")

        # start background thread
        inner_work = InnerWorkEncryption(is_primary, self)
        self.inner_work_list.append(inner_work)
        inner_work.start()
        return inner_work.event

    def validate_the_other(self, is_primary: bool) -> Event:
        """validate the other by publicKey"""
        if is_primary and self.stype != SockType.INBOUND:
            log.warning("validate_the_other() is INBOUND work")

        # start background thread
        inner_work = InnerWorkValidation(is_primary, self)
        self.inner_work_list.append(inner_work)
        inner_work.start()

        return inner_work.event

    def measure_delay_time(self, is_primary: bool) -> Event:
        """check delay time by ping"""
        if is_primary and self.stype != SockType.INBOUND:
            log.warning("validate_the_other() is INBOUND work")

        # start background thread
        inner_work = InnerWorkMeasureTime(is_primary, self)
        self.inner_work_list.append(inner_work)
        inner_work.start()

        return inner_work.event

    def get_opposite_host(self) -> _Host:
        """get the other end of the connection host name"""
        family: Union[Type[IPv4Address], Type[IPv6Address]]

        if self.sock.family is s.AF_INET:
            family = IPv4Address
        elif self.sock.family is s.AF_INET6:
            family = IPv6Address
        else:
            raise NotImplementedError(f"not found family: {self.sock.family}")

        # note: raise OSError if socket is closed
        if self.stype is SockType.SERVER:
            return family(self.sock.getsockname()[0])
        elif self.stype is SockType.INBOUND:
            return family(self.sock.getpeername()[0])
        elif self.stype is SockType.OUTBOUND:
            return family(self.sock.getpeername()[0])
        else:
            raise NotImplementedError(f"not found stype: {self.stype}")

    def is_srudp(self) -> bool:
        """check the socket is pseudo TCP"""
        return isinstance(self.sock, SecureReliableSocket)

    def fileno(self) -> int:
        """is for select poll"""
        return self.sock.fileno()

    def close(self) -> None:
        """note: use pool's close_sock() instead"""
        now = time()
        for work in self.inner_work_list:
            work.event.wait(20.0)
        if 0 < self.sock.fileno():
            self.sock.close()
        log.debug("%s closed %fs", self, time() - now)


class SockPool(Thread):
    def __init__(
            self,
            cb_accept: CallbackAccept = None,
            cb_close: CallbackClose = None,
            secret: bytes = None,
    ) -> None:
        super().__init__(name="SockPool")
        self.cb_accept = cb_accept
        self.cb_close = cb_close
        self.socks: List[Sock] = list()
        self.lock = Lock()
        if secret is None:
            self.secret_key = SigningKey.generate(CURVE)
        else:
            self.secret_key = SigningKey.from_string(secret, CURVE)
        # status
        self.running = Event()  # main thread is working
        self.closing = False  # is closing now
        self.closed = False  # class is closed
        # init
        self.running.set()

    def __repr__(self) -> str:
        public_key = self.secret_key.get_verifying_key().to_string().hex()
        if self.closed:
            status = "closed"
        elif self.closing:
            status = "closing"
        elif not self.running.is_set():
            status = "running"
        else:
            status = "waiting"
        return f"<SockPool pub={public_key[:10]}..{public_key[-10:]} status={status} len={len(self.socks)}>"

    def run(self) -> None:
        assert self.running.is_set(), "already running main thread"
        r: List[Sock]

        self.running.clear()

        # listen sockets
        while not self.closing:
            # note: only socket object is supported on windows
            with self.lock:
                listen = [sock for sock in self.socks if 0 < sock.fileno()]

            if len(listen) == 0:
                sleep(0.2)
                continue
            else:
                r, _w, _x = select(listen, [], [], 0.2)

            # socket recv() or accept()
            for sock in r:
                now = time()
                try:
                    if sock.stype is SockType.SERVER:
                        # server type
                        raw_sock, _address = sock.sock.accept()
                        raw_sock.settimeout(0.0)
                        new_sock = Sock(raw_sock, sock.callback, SockType.INBOUND, None, self.secret_key)
                        with self.lock:
                            self.socks.append(new_sock)
                        if self.cb_accept is not None:
                            Thread(target=self.cb_accept, args=(new_sock, self)).start()
                        log.debug("accept %s", new_sock)

                    else:
                        # client type
                        sock.recv()

                except NotImplementedError as e:
                    log.info("NotImplementedError %s %s", sock, e)
                except JobCorruptedWarning as e:
                    log.debug("JobCorruptedWarning %s %s", sock, e)
                except GracefulCloseSignal as e:
                    log.debug("GracefulClose %s", e)
                    self.close_sock(sock)
                except UnrecoverableClose as e:
                    log.info("UnrecoverableClose %s %s", sock, e)
                    self.close_sock(sock)
                except ConnectionError as e:
                    log.info("ConnectionError %s %s", sock, e)
                    self.close_sock(sock)
                except OSError as e:
                    log.debug("socket sudden close by %s", e)
                    self.close_sock(sock)
                except Exception:
                    log.warning("Exception %s", sock, exc_info=True)
                    self.close_sock(sock)
                finally:
                    # check blocking bug
                    delay = time() - now
                    if 10.0 <= delay:
                        log.warning("%s listen loop is blocked! %ss", sock, delay)

        # closing
        log.debug("listening thread closing len=%d", len(self.socks))
        for sock in self.socks.copy():
            self.close_sock(sock, b"close sock pool now")
        log.info("listening thread close success")
        self.running.set()

    def add_sock(self, sock: Sock) -> None:
        """add new sock, client or server"""
        assert sock not in self.socks
        assert sock.secret_key is self.secret_key

        if sock.stype is SockType.SERVER:
            assert sock.others_key is None
            sock.stable.set()

        elif sock.stype is SockType.INBOUND:
            assert sock.is_srudp(), ("not allow inbound sock adding", sock)

        elif sock.stype is SockType.OUTBOUND:
            pass

        else:
            raise NotImplementedError("unexpected sockType {}".format(sock))

        # note: maybe block max 0.2sec
        with self.lock:
            self.socks.append(sock)
        log.info("add new %s", sock)

    def get_sock_from_addr(self, address: _Address) -> Optional[Sock]:
        """get validated sock from host"""
        with self.lock:
            for sock in self.socks:
                if sock.flags & SockControl.VALIDATED and sock.sock.getpeername() == address:
                    return sock
        return None

    def close_sock(self, sock: Sock, reason: bytes = None) -> None:
        """graceful socket close"""
        try:
            if 0 < sock.fileno():
                # send reason if socket is working
                if isinstance(reason, bytes) and sock.stype in (SockType.INBOUND, SockType.OUTBOUND):
                    sock.sendall(reason, SockControl.CLOSING)
                # close socket
                sock.close()
                log.debug("close %s by `%s`", sock, reason)
            else:
                pass
        except ConnectionError as e:
            log.debug("ConnectionError %s", e)
        except Exception:
            log.debug("Exception", exc_info=True)

        # remove from list
        with self.lock:
            if sock in self.socks:
                self.socks.remove(sock)
                log.info("remove %s from sockpool", sock)
            else:
                pass

        # execute callback last
        if self.cb_close is not None:
            self.cb_close(sock, self)

    def close(self) -> None:
        """close and wait complete status"""
        self.closing = True
        self.running.wait()
        self.closed = True


__all__ = [
    "CallbackReceive",
    "SockControl",
    "SockType",
    "UnrecoverableClose",
    "JobCorruptedWarning",
    "Sock",
    "SockPool",
]
